Javascript-EventLoop
### 异步编程
1. callback
2. Promise
3. generator
4. async

### callback缺点
1. 回调地狱
2. 维护困难
3. 函数拆分可以解决嵌套问题，但可读性差

### Promise
- Promise是一个构造函数，其创建promise对象后参数executor自动执行
```
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

})
```
- 状态机：pending到fulfilled或rejected单向流动


- then返回thenable对象，并自动调用其内部then方法
  - thenable对象：实现了then方法的对象，会被当做promise来对待，主要是为了便于第三方库实现自己的promise兼容对象
```
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // 1 秒后使用 this.num*2 进行 resolve
    setTimeout(() => resolve(this.num * 2), 1000); // (**)
  }
}
```
|
- catch是then(null, f)的别名
- finally效果与then(f, f)相同，但区别在于
  - finally的回调没有参数，不知道promise状态
  - finally将结果和error直接传递给下一个处理程序

API
- Promise.all
- Promise.allSettled
- Promise.race
- Promise.reject
- Promise.resolve
Promise错误处理
- executor和handler内部存在隐式try...catch，可以捕获同步错误，故throw err与reject(err)等价
```
    new Promise((resolve, reject) => {
        throw new Error("Whoops!");
    }).catch(alert); // Error: Whoops!

    new Promise((resolve, reject) => {
        reject(new Error("Whoops!"));
    }).catch(alert); // Error: Whoops!
```
- catch正常完成后，返回的Promise状态是fulfill
- catch中如果再次抛出，返回的Promise状态是rejected
外部错误捕获
- 微任务队列完成时，unhandledrejection事件捕获未处理的Promise错误 unhandledrejection，HTML标准
window.addEventListener('unhandledrejection', function(event) {
  // 这个事件对象有两个特殊的属性：
  alert(event.promise); // [object Promise] - 生成该全局 error 的 promise
  alert(event.reason); // Error: Whoops! - 未处理的 error 对象
});

Async
使用方法
- async函数总是返回一个promise
- await等待promise执行完成后，以promise的执行结果继续执行。在此过程中，引擎可以处理其他任务
- await命令只能在async函数中使用
```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // 等待，直到 promise resolve (*)

  alert(result); // "done!"
}

f();
```
错误捕获
- 内部try...catch
async function f() {
  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // 捕获到 fetch 和 response.json 中的错误
    alert(err);
  }
}
- async执行结果增加catch方法
async function f() {
  let response = await fetch('http://no-such-url');
}

// f() 变成了一个 rejected 的 promise
f().catch(alert); // TypeError: failed to fetch // (*)
- 不处理会被unhandledrejection事件捕获

Generator
```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```


