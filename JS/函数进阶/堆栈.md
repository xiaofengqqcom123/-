## 递归
表示从自身调用函数（译注：也就是自调用）

最大递归深度受限于 JavaScript 引擎。对我们来说，引擎在最大迭代深度为 10000 及以下时是可靠的，有些引擎可能允许更大的最大深度，但是对于大多数引擎来说，100000 可能就超出限制了。有一些自动优化能够帮助减轻这种情况（尾部调用优化），但目前它们还没有被完全支持，只能用于简单场景

## 函数底层的工作原理
有关正在运行的函数的执行过程的相关信息被存储在其 执行上下文 中。

最大的嵌套调用次数（包括首次）被称为 递归深度

执行上下文 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。

任何递归都可以用循环来重写。通常循环变体更有效。

## 链表
在数组首位插入、删除元素的操作代价大，如果数据比较大，会很耗时。如果我们确实需要快速插入/删除，则可以选择另一种叫做 链表 的数据结构。
```
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```
- 优势：新增、删除元素时，链表没有大规模重排，我们可以很容易地重新排列元素
- 缺点：无法通过元素的编号获取元素，但在数组中却很容易：arr[n] 是一个直接引用。而在链表中，我们需要从起点元素开始，顺着 next 找 N 次才能获取到第 N 个元素。
