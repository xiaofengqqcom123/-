在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）

### 数字类型转换
1. Number(value): 将value转换为number类型;
```
undefined	NaN
null	0
true 和 false	1 and 0
string	“按原样读取”字符串，两端的空白会被忽略。空字符串变成 0。转换出错则输出 NaN
```
2. 隐式转换: 
-  alert：在算术函数和表达式中，会自动进行 number 类型转换; 例如: alert( "6" / "2" )
- 一元运算符+：对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。
```
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0

" \t \n" - 2; // -2
```

### BigInt
在 JavaScript 中，“number” 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数。BigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。
为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n
```
1234 // 普通整数
1234n // BigInt
```

### Unicode
所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。

但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。
```
alert( '𝒳'.length ); // 2，大写数学符号 X
alert( '😂'.length ); // 2，笑哭表情
alert( '𩷶'.length ); // 2，罕见的中国象形文字

可处理 代理对的方法
'𝒳'[0] // 乱码了
'𝒳'.charCodeAt(0) // 55349

'S\u0307\u0323'  // "Ṩ"
'S\u0323\u0307' // "Ṩ"

我们发现相同的字符，可以用不同的unicode代码表示，为了解决这个问题，引入了 “unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。
"S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() // true
"S\u0307\u0323".normalize().length // 1
```
### Boolean
准换规则: 
- 直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。
- 其他值变成 true. (注意字符串中的"0",为true)

### 原始类型的方法 [参考](https://zh.javascript.info/primitives-methods)
以下是 JavaScript 创建者面临的悖论：

- 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好将它们作为方法来访问。
- 原始类型必须尽可能的简单轻量。

解决方案：
- 原始类型仍然是原始的。与预期相同，提供单个值
- JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。
- 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁

```
let str = "Hello";

alert( str.toUpperCase() ); // HELLO

// 发生了什么？
1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。
2. 该方法运行并返回一个新的字符串（由 alert 显示）。
3. 特殊对象被销毁，只留下原始值 str
```
除 null 和 undefined 以外的原始类型都提供了许多有用的方法

