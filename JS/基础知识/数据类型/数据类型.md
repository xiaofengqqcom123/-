在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）

### 数字类型转换
1. Number(value): 将value转换为number类型;
```
undefined	NaN
null	0
true 和 false	1 and 0
string	“按原样读取”字符串，两端的空白会被忽略。空字符串变成 0。转换出错则输出 NaN
```
2. 隐式转换: 
-  alert：在算术函数和表达式中，会自动进行 number 类型转换; 例如: alert( "6" / "2" )
- 一元运算符+：对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。
```
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0

" \t \n" - 2; // -2
```

### BigInt
在 JavaScript 中，“number” 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数。BigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。
为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n
```
1234 // 普通整数
1234n // BigInt
```

### String
字符串的内部格式始终是 UTF-16，它不依赖于页面编码

#### 1. 字符串类型转换：
- alert value: 将 value 转换为字符串类型，然后显示这个值
- String(value) : 将 value 转换为字符串类型
- 隐私转换：
```
// 二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
alert(2 + 2 + '1' ); // "41"，不是 "221"
```

#### 2. 转义字符
\u{X…XXXXXX} （1 到 6 个十六进制字符）
具有给定 UTF-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。
```
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫，罕见的中国象形文字（长 unicode）
alert( "\u{1F60D}" ); // 😍，笑脸符号（另一个长 unicode)
```

#### 3. 访问字符
- 使用方括号 [pos]
- 调用 str.charAt(pos) 方法

它们之间的唯一区别是，如果没有找到字符，[] 返回 undefined，而 charAt 返回一个空字符串：
```
let str = `Hello`;

alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // ''（空字符串）
```


### Boolean
准换规则: 
- 直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。
- 其他值变成 true. (注意字符串中的"0",为true)

### 原始类型的方法 [参考](https://zh.javascript.info/primitives-methods)
以下是 JavaScript 创建者面临的悖论：

- 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好将它们作为方法来访问。
- 原始类型必须尽可能的简单轻量。

解决方案：
- 原始类型仍然是原始的。与预期相同，提供单个值
- JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。
- 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁

```
let str = "Hello";

alert( str.toUpperCase() ); // HELLO

// 发生了什么？
1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。
2. 该方法运行并返回一个新的字符串（由 alert 显示）。
3. 特殊对象被销毁，只留下原始值 str
```
除 null 和 undefined 以外的原始类型都提供了许多有用的方法