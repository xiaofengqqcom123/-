在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）

### 数字类型转换
1. Number(value): 将value转换为number类型;
```
undefined	NaN
null	0
true 和 false	1 and 0
string	“按原样读取”字符串，两端的空白会被忽略。空字符串变成 0。转换出错则输出 NaN
```
2. 隐式转换: 
-  alert：在算术函数和表达式中，会自动进行 number 类型转换; 例如: alert( "6" / "2" )
- 一元运算符+：对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。
```
// 对数字无效
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 转化非数字
alert( +true ); // 1
alert( +"" );   // 0

" \t \n" - 2; // -2
```

### BigInt
在 JavaScript 中，“number” 类型无法表示大于 (253-1)（即 9007199254740991），或小于 -(253-1) 的整数。BigInt 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。
为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n
```
1234 // 普通整数
1234n // BigInt
```

### Unicode
所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。

但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。
```
alert( '𝒳'.length ); // 2，大写数学符号 X
alert( '😂'.length ); // 2，笑哭表情
alert( '𩷶'.length ); // 2，罕见的中国象形文字

可处理 代理对的方法
'𝒳'[0] // 乱码了
'𝒳'.charCodeAt(0) // 55349

'S\u0307\u0323'  // "Ṩ"
'S\u0323\u0307' // "Ṩ"

我们发现相同的字符，可以用不同的unicode代码表示，为了解决这个问题，引入了 “unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。
"S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() // true
"S\u0307\u0323".normalize().length // 1
```
### Boolean
准换规则: 
- 直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。
- 其他值变成 true. (注意字符串中的"0",为true)

### 原始类型的方法 [参考](https://zh.javascript.info/primitives-methods)
以下是 JavaScript 创建者面临的悖论：

- 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好将它们作为方法来访问。
- 原始类型必须尽可能的简单轻量。

解决方案：
- 原始类型仍然是原始的。与预期相同，提供单个值
- JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。
- 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁

```
let str = "Hello";

alert( str.toUpperCase() ); // HELLO

// 发生了什么？
1. 字符串 str 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()。
2. 该方法运行并返回一个新的字符串（由 alert 显示）。
3. 特殊对象被销毁，只留下原始值 str
```
除 null 和 undefined 以外的原始类型都提供了许多有用的方法

### Array
数组是一种特殊的对象。使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）

队列：先进先出，FIFO（First-In-First-Out）

栈：先进后厨，LIFO（Last-In-First-Out）

JavaScript 中的数组既可以用作队列，也可以用作栈. 这在计算机科学中，允许这样的操作的数据结构被称为 双端队列（deque）。

#### 内部
数组是一种特殊的对象，使用方括号来访问属性 arr[0] 实际上是来自于对象的语法。它其实与 obj[key] 相同，其中 arr 是对象，而数字用作键（key）。

它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 length 属性。但从本质上讲，它仍然是一个对象。

从技术上讲，我们可以这样做：
```
let fruits = []; // 创建一个数组
fruits.age = 25; // 创建一个具有任意名称的属性
fruits.age // 25

// 因为数组是基于对象的，所以我们可以给它们添加任意属性。但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了
```
数组误用的几种方式:

- 添加一个非数字的属性，比如 arr.test = 5。
- 制造空洞，比如：添加 arr[0]，然后添加 arr[1000] (它们中间什么都没有)。
- 以倒序填充数组，比如 arr[1000]，arr[999] 等等。

#### 性能
我们发现，push、pop 比 shift、unshift要快
```
let arr = []
for(let i = 0; i < 10000; i ++) {
    arr.push(i)
}

console.time(1)
arr.push('hello')
console.timeEnd(1)

console.time(2)
arr.unshift('word')
console.timeEnd(2)

VM913:3 1: 0.005126953125 ms
VM913:6 2: 16745.4609375 ms
```
shift 需要做三件事：
- 移除索引为 0 的元素
- 把所有的元素向左移动，把索引 1 改成 0，2 改成 1 以此类推，对其重新编号
- 更新length 属性

数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。


pop 需要做
- 移出 索引为 (length - 1) 的元素
- 更新length属性
pop 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 pop 会特别快。

#### toString
```
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```